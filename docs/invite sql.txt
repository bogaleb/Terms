-- Helper functions required by the RLS policies.
-- Keep this section in sync with supabase/schema/supabase_functions.sql

-- Canonical helper function definitions referenced by RLS policies.
-- Keep in sync with supabase/schema/supabase_rls_policies.sql.

drop function if exists public.user_has_org_role(uuid, text[]) cascade;
drop function if exists public.user_has_business_role(uuid, text[]) cascade;

create or replace function public.user_has_org_role(p_org_id uuid, roles text[])
returns boolean
language plpgsql
security definer
set search_path = public
stable
as $$
declare
  current_user_id uuid := auth.uid();
  allowed_roles text[] := coalesce(roles, array['owner','admin','member','viewer']);
begin
  if p_org_id is null or current_user_id is null then
    return false;
  end if;

  return exists (
    select 1
    from public.organization_members om
    where om.organization_id = p_org_id
      and om.user_id = current_user_id
      and om.role::text = any(allowed_roles)
  );
end;
$$;

create or replace function public.user_has_business_role(p_business_id uuid, roles text[])
returns boolean
language plpgsql
security definer
set search_path = public
stable
as $$
declare
  current_user_id uuid := auth.uid();
  allowed_roles text[] := coalesce(roles, array['owner','admin','member','viewer']);
begin
  if p_business_id is null or current_user_id is null then
    return false;
  end if;

  return exists (
    select 1
    from public.business_members bm
    where bm.business_id = p_business_id
      and bm.user_id = current_user_id
      and bm.role::text = any(allowed_roles)
  );
end;
$$;

create or replace function public.user_is_entry_owner(entry_id uuid)
returns boolean
language plpgsql
security definer
set search_path = public
stable
as $$
declare
  current_user_id uuid := auth.uid();
begin
  if entry_id is null or current_user_id is null then
    return false;
  end if;

  return exists (
    select 1
    from public.entries e
    where e.id = entry_id
      and e.created_by = current_user_id
  );
end;
$$;

create or replace function public.organization_has_members(org_id uuid)
returns boolean
language sql
security definer
set search_path = public
stable
as $$
  select exists (
    select 1
    from public.organization_members om
    where om.organization_id = org_id
  );
$$;

create or replace function public.business_has_members(business_id uuid)
returns boolean
language sql
security definer
set search_path = public
stable
as $$
  select exists (
    select 1
    from public.business_members bm
    where bm.business_id = business_id
  );
$$;

-- Ensure compatible signature by dropping any previous version first
drop function if exists public.accept_invite(text);

create or replace function public.accept_invite(raw_token text)
returns public.invites
language plpgsql
security definer
set search_path = public
as $$
declare
  current_user_id uuid := auth.uid();
  hashed_token text;
  invite_row public.invites%rowtype;
  existing_org_member public.organization_members%rowtype;
  existing_business_member public.business_members%rowtype;
begin
  if current_user_id is null then
    raise exception 'Not authenticated';
  end if;

  if raw_token is null or length(raw_token) = 0 then
    raise exception 'Missing invite token';
  end if;

  hashed_token := encode(extensions.digest(raw_token::bytea, 'sha256'), 'hex');

  select *
    into invite_row
    from public.invites
    where token_hash = hashed_token
      and revoked_at is null
      and accepted_at is null
      and expires_at > timezone('utc', now())
    for update;

  if not found then
    raise exception 'Invite not found or already used';
  end if;

  select *
    into existing_org_member
    from public.organization_members
    where organization_id = invite_row.organization_id
      and user_id = current_user_id;

  if existing_org_member is null then
    insert into public.organization_members (
      organization_id,
      user_id,
      role,
      invited_by,
      invited_at,
      joined_at
    ) values (
      invite_row.organization_id,
      current_user_id,
      invite_row.role,
      invite_row.created_by,
      invite_row.created_at,
      timezone('utc', now())
    )
    returning * into existing_org_member;
  else
    update public.organization_members
      set role = greatest(existing_org_member.role::text, invite_row.role::text)::public.membership_role,
          joined_at = coalesce(existing_org_member.joined_at, timezone('utc', now()))
      where id = existing_org_member.id
    returning * into existing_org_member;
  end if;

  if invite_row.business_id is not null then
    select *
      into existing_business_member
      from public.business_members
      where business_id = invite_row.business_id
        and user_id = current_user_id;

    if existing_business_member is null then
      insert into public.business_members (
        business_id,
        organization_id,
        user_id,
        role
      ) values (
        invite_row.business_id,
        invite_row.organization_id,
        current_user_id,
        invite_row.role
      )
      returning * into existing_business_member;
    else
      update public.business_members
        set role = greatest(existing_business_member.role::text, invite_row.role::text)::public.membership_role
        where id = existing_business_member.id
      returning * into existing_business_member;
    end if;
  end if;

  update public.invites
    set accepted_at = timezone('utc', now())
    where id = invite_row.id;

  return invite_row;
end;
$$;

-- Enable RLS and define policies aligned with EtBook tenancy model

alter table public.profiles enable row level security;
alter table public.profiles force row level security;

drop policy if exists "Profiles select" on public.profiles;
create policy "Profiles select" on public.profiles
  for select
  using (auth.role() = 'service_role' or auth.uid() = user_id);

drop policy if exists "Profiles upsert" on public.profiles;
create policy "Profiles upsert" on public.profiles
  for insert
  with check (auth.role() = 'service_role' or auth.uid() = user_id);

drop policy if exists "Profiles update" on public.profiles;
create policy "Profiles update" on public.profiles
  for update
  using (auth.role() = 'service_role' or auth.uid() = user_id)
  with check (auth.role() = 'service_role' or auth.uid() = user_id);

alter table public.organizations enable row level security;
alter table public.organizations force row level security;

drop policy if exists "Organizations select" on public.organizations;
create policy "Organizations select" on public.organizations
  for select
  using (
    auth.role() = 'service_role'
    or public.user_has_org_role(id, array['owner','admin','member','viewer'])
    or created_by = auth.uid()
  );

drop policy if exists "Organizations insert" on public.organizations;
create policy "Organizations insert" on public.organizations
  for insert
  with check (auth.role() = 'service_role' or auth.uid() is not null);

drop policy if exists "Organizations update" on public.organizations;
create policy "Organizations update" on public.organizations
  for update
  using (
    auth.role() = 'service_role'
    or public.user_has_org_role(id, array['owner','admin'])
  )
  with check (
    auth.role() = 'service_role'
    or public.user_has_org_role(id, array['owner','admin'])
  );

drop policy if exists "Organizations delete" on public.organizations;
create policy "Organizations delete" on public.organizations
  for delete
  using (auth.role() = 'service_role' or public.user_has_org_role(id, array['owner']));

alter table public.organization_members enable row level security;
alter table public.organization_members force row level security;

drop policy if exists "Org members select" on public.organization_members;
create policy "Org members select" on public.organization_members
  for select
  using (
    auth.role() = 'service_role'
    or public.user_has_org_role(organization_id, array['owner','admin','member','viewer'])
  );

drop policy if exists "Org members insert" on public.organization_members;
create policy "Org members insert" on public.organization_members
  for insert
  with check (
    auth.role() = 'service_role'
    or auth.uid() = user_id
    or public.user_has_org_role(organization_id, array['owner','admin'])
    or (
      auth.uid() = user_id
      and public.organization_has_members(organization_id) = false
    )
    or exists (
      select 1 from public.organizations o
      where o.id = organization_id and o.created_by = auth.uid()
    )
  );

drop policy if exists "Org members update" on public.organization_members;
create policy "Org members update" on public.organization_members
  for update
  using (
    auth.role() = 'service_role'
    or public.user_has_org_role(organization_id, array['owner','admin'])
  )
  with check (
    auth.role() = 'service_role'
    or public.user_has_org_role(organization_id, array['owner','admin'])
  );

drop policy if exists "Org members delete" on public.organization_members;
create policy "Org members delete" on public.organization_members
  for delete
  using (
    auth.role() = 'service_role'
    or public.user_has_org_role(organization_id, array['owner'])
  );

alter table public.businesses enable row level security;
alter table public.businesses force row level security;

drop policy if exists "Businesses select" on public.businesses;
create policy "Businesses select" on public.businesses
  for select
  using (
    auth.role() = 'service_role'
    or public.user_has_org_role(organization_id, array['owner','admin','member','viewer'])
  );

drop policy if exists "Businesses insert" on public.businesses;
create policy "Businesses insert" on public.businesses
  for insert
  with check (
    auth.role() = 'service_role'
    or public.user_has_org_role(organization_id, array['owner','admin'])
  );

drop policy if exists "Businesses update" on public.businesses;
create policy "Businesses update" on public.businesses
  for update
  using (
    auth.role() = 'service_role'
    or public.user_has_business_role(id, array['owner','admin'])
  )
  with check (
    auth.role() = 'service_role'
    or public.user_has_business_role(id, array['owner','admin'])
  );

drop policy if exists "Businesses delete" on public.businesses;
create policy "Businesses delete" on public.businesses
  for delete
  using (
    auth.role() = 'service_role'
    or public.user_has_business_role(id, array['owner','admin'])
  );

alter table public.business_members enable row level security;
alter table public.business_members force row level security;

drop policy if exists "Business members select" on public.business_members;
create policy "Business members select" on public.business_members
  for select
  using (
    auth.role() = 'service_role'
    or public.user_has_org_role(organization_id, array['owner','admin','member','viewer'])
  );

drop policy if exists "Business members insert" on public.business_members;
create policy "Business members insert" on public.business_members
  for insert
  with check (
    auth.role() = 'service_role'
    or auth.uid() = user_id
    or public.user_has_business_role(business_id, array['owner','admin'])
    or (
      auth.uid() = user_id
      and public.business_has_members(business_id) = false
      and public.user_has_org_role(organization_id, array['owner'])
    )
    or exists (
      select 1 from public.businesses b
      where b.id = business_id and b.organization_id = organization_id and b.created_by = auth.uid()
    )
  );

drop policy if exists "Business members update" on public.business_members;
create policy "Business members update" on public.business_members
  for update
  using (
    auth.role() = 'service_role'
    or public.user_has_business_role(business_id, array['owner','admin'])
  )
  with check (
    auth.role() = 'service_role'
    or public.user_has_business_role(business_id, array['owner','admin'])
  );

drop policy if exists "Business members delete" on public.business_members;
create policy "Business members delete" on public.business_members
  for delete
  using (
    auth.role() = 'service_role'
    or public.user_has_business_role(business_id, array['owner'])
  );

alter table public.books enable row level security;
alter table public.books force row level security;

drop policy if exists "Books select" on public.books;
create policy "Books select" on public.books
  for select
  using (
    auth.role() = 'service_role'
    or public.user_has_business_role(business_id, array['owner','admin','member','viewer'])
  );

drop policy if exists "Books insert" on public.books;
create policy "Books insert" on public.books
  for insert
  with check (
    auth.role() = 'service_role'
    or public.user_has_business_role(business_id, array['owner','admin'])
  );

drop policy if exists "Books update" on public.books;
create policy "Books update" on public.books
  for update
  using (
    auth.role() = 'service_role'
    or public.user_has_business_role(business_id, array['owner','admin'])
  )
  with check (
    auth.role() = 'service_role'
    or public.user_has_business_role(business_id, array['owner','admin'])
  );

drop policy if exists "Books delete" on public.books;
create policy "Books delete" on public.books
  for delete
  using (
    auth.role() = 'service_role'
    or public.user_has_business_role(business_id, array['owner','admin'])
  );

alter table public.entries enable row level security;
alter table public.entries force row level security;

drop policy if exists "Entries select" on public.entries;
create policy "Entries select" on public.entries
  for select
  using (
    auth.role() = 'service_role'
    or public.user_has_business_role(business_id, array['owner','admin','member','viewer'])
  );

drop policy if exists "Entries insert" on public.entries;
create policy "Entries insert" on public.entries
  for insert
  with check (
    auth.role() = 'service_role'
    or public.user_has_business_role(business_id, array['owner','admin','member'])
  );

drop policy if exists "Entries update" on public.entries;
create policy "Entries update" on public.entries
  for update
  using (
    auth.role() = 'service_role'
    or public.user_has_business_role(business_id, array['owner','admin'])
    or public.user_is_entry_owner(id)
  )
  with check (
    auth.role() = 'service_role'
    or public.user_has_business_role(business_id, array['owner','admin'])
    or public.user_is_entry_owner(id)
  );

drop policy if exists "Entries delete" on public.entries;
create policy "Entries delete" on public.entries
  for delete
  using (
    auth.role() = 'service_role'
    or public.user_has_business_role(business_id, array['owner','admin'])
    or public.user_is_entry_owner(id)
  );

alter table public.invites enable row level security;
alter table public.invites force row level security;

drop policy if exists "Invites select" on public.invites;
create policy "Invites select" on public.invites
  for select
  using (
    auth.role() = 'service_role'
    or public.user_has_org_role(organization_id, array['owner','admin'])
  );

drop policy if exists "Invites insert" on public.invites;
create policy "Invites insert" on public.invites
  for insert
  with check (
    auth.role() = 'service_role'
    or public.user_has_org_role(organization_id, array['owner','admin'])
  );

drop policy if exists "Invites update" on public.invites;
create policy "Invites update" on public.invites
  for update
  using (
    auth.role() = 'service_role'
    or public.user_has_org_role(organization_id, array['owner','admin'])
  )
  with check (
    auth.role() = 'service_role'
    or public.user_has_org_role(organization_id, array['owner','admin'])
  );

drop policy if exists "Invites delete" on public.invites;
create policy "Invites delete" on public.invites
  for delete
  using (
    auth.role() = 'service_role'
    or public.user_has_org_role(organization_id, array['owner'])
  );




